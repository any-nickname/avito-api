![gopher image](https://raw.githubusercontent.com/tottie000/GopherIllustrations/main/Gopher_Illustrations/don't_panic.png)

_<font size="2">The Go gopher was designed by Renée French. Illustrations by tottie.</font>_

# Сервис по работе с сегментами

Проект представляет собой микросервис, предоставляющий функционал по работе с сегментами пользователей.
Проект предназначен для решения задач аналитики.

Технологии:
- PostgreSQL (хранилище данных)
- Docker (для развёртывания dev-среды)
- Swagger (документация API)
- Echo (веб-фреймворк)
- pgx (драйвер для работы с PostgreSQL)
- golang/mock, testify (для юнит-тестов)
- google drive (лёгкое облачное хранилище)

Проект построен согласно идеям чистой архитектуры, что позволяет, при необходимости, комфортно и быстро расширять его в
будущем.
Для плавного выключения сервиса реализован Graceful Shutdown.

## Запуск проекта
Проект включает в себя функционал по формированию отчётов (маршрут `/api/v1/reports`). Сформированные отчёты могут
загружаться как на гугл-диск (тогда в ответе будет возвращаться ссылка на файл), так и возвращаться непосредственно в
теле ответного HTTP-сообщения. Поэтому, перед тем, как запустить проект, Вам необходимо определиться, в каком виде 
Вы хотите получать отчёты.

#### (Сложный старт) Если Вам требуется загрузка отчётов на гугл-диск с последующим возвратом ссылки на загруженный файл:

1. Зарегистрируйте своё приложение в Google Cloud Console: [Документация](https://developers.google.com/workspace/guides/create-project).
2. Создайте сервисную учётную запись и пару ключей для доступа к ней: [Документация](https://developers.google.com/workspace/guides/create-credentials) (раздел _Service account credentials_).
3. Скачайте json-файл, содержащий пару ключей для доступа к вашему сервисному аккаунту (например, `your_credentials.json`),
и поместите его в директорию `secrets/your_credentials.json`.
4. Дайте проекту знать, где находится файл с ключами, с помощью переменной `GOOGLE_DRIVE_JSON_FILE_PATH` в `.env`-файле
или соответствующей структуры в `config.yaml` файле: 
```yaml
webapi:
  google_drive_json_file_path: secrets/your_credentials.json
```
5. (Опционально) Настройте `config` или `.env`-файл под себя.
6. Запустите проект с помощью `make up`.

#### (Быстрый старт) Если Вам не требуется загрузка отчётов в облако:

1. В `.env` и `config` не добавляйте поле, отвечающее за путь к файлу с ключом (`webapi: google_drive_json_file_path` в `config.yaml` и `GOOGLE_DRIVE_JSON_FILE_PATH` в `.env`).
2. (Опционально) Настройте `config` или `.env`-файл под себя.
3. Запустите проект с помощью `make up`.

После запуска, для того, чтобы проверить работу бекэнда, Вы можете отправить GET-запрос по адресу
http://localhost:8080/health

Для доступа к swagger-файлу перейдите по адресу http://localhost:8080/swagger/

## Список команд
`make up` - используйте команду "make up" для запуска проекта (перед использованием команды make на компьютере должна быть установлена GNU Make).

`make stop` - используйте для остановки контейнера с проектом.

`make down` - если Вы внесли изменения в приложение и хотите пересобрать проект, используйте команду "make down", которая остановит и
удалит все контейнеры, связанные с проектом, а также старый образ приложения (но оставит образ postgres). Теперь, когда
Вы воспользуетесь "make up", будет собран новый образ приложения.

`make test` - используйте для запуска юнит-тестов. На текущий момент, юнит-тестами покрыт весь слой "controller".

`make swag` - используйте для автоматической генерации swagger-файла на основе аннотаций, описанных в файлах слоя 
"controller".

## Конфигурация проекта

Для конфигурирования проекта Вы можете использовать как `config`, так и `.env`-файл.

| `config.yaml`                       | `.env`                      | Описание                                                                                                                              | Тип данных | Пример                   | Диапазон значений                               |
|-------------------------------------|-----------------------------|---------------------------------------------------------------------------------------------------------------------------------------|------------|--------------------------|-------------------------------------------------|
| app: name                           | APP_NAME                    | Имя проекта                                                                                                                           | String     | segmentation-service     |                                                 |
| app: version                        | APP_VERSION                 | Версия проекта                                                                                                                        | String     | 1.0.0                    |                                                 |
| log: level                          | LOG_LEVEL                   | Уровень логирования                                                                                                                   | String     | debug                    | [trace, debug, info, warn, error, fatal, panic] |
| log: logs_path                      | LOGS_PATH                   | Путь сохранения файла с логами                                                                                                        | String     | logs/logs.txt            |                                                 |
| http: bind_ip                       | HTTP_BIND_IP                | IP-адрес, по которому доступен сервер                                                                                                 | String     | localhost                |                                                 |
| http: port                          | HTTP_PORT                   | Порт, по которому доступен сервер                                                                                                     | String     | 8080                     |                                                 |
| postgresql: host                    | POSTGRES_HOST               | IP-адрес, по которому доступен сервер с БД                                                                                            | String     | localhost                |                                                 |
| postgresql: port                    | POSTGRES_PORT               | Порт, по которому доступен сервер с БД                                                                                                | String     | 5432                     |                                                 |
| postgresql: username                | POSTGRES_USER               | Имя пользователя для подключения к БД                                                                                                 | String     | root                     |                                                 |
| postgresql: password                | POSTGRES_PASSWORD           | Пароль пользователя для подключения к БД                                                                                              | String     | root                     |                                                 | 
| postgresql: database                | POSTGRES_DATABASE           | Наименование базы данных для подключения                                                                                              | String     | segmentation-service     |                                                 |
| postgresql: max_pool_size           | POSTGRES_MAX_POOL_SIZE      | Максимальное количество соединений, которые могут быть установлены с БД одновременно                                                  | Integer    | 20                       | \> 0                                            |
| webapi: google_drive_json_file_path | GOOGLE_DRIVE_JSON_FILE_PATH | Путь до файла с парой ключей для доступа к сервисной учётной записи Google Cloud. Если Google Cloud не используется, удалите это поле | String     | secrets/credentials.json |                                                 |

### _Приоритет конфигураций_
Переменные окружения имеют приоритет над значениями из `config`-файла, и, если одна и та же переменная
обозначена в обоих (`config.yaml` и `.env`) файлах, то будет взято значение из `.env`-файла.

К примеру, если Вы укажете путь до файла с ключами доступа к сервисному аккаунту в `config`-файле:
```yaml
webapi:
  google_drive_json_file_path: secrets/credentials.json
```

и при этом укажете в `.env`-файле что-то подобное:
```text
GOOGLE_DRIVE_JSON_FILE_PATH=
```

это приведёт к тому, что значение, указанное в `config`-файле будет перезаписано пустой строкой из `.env`-файла, так как
`.env`-файл имеет приоритет над `config`. Это касается и любых других конфигураций. Старайтесь использовать только один
из файлов (`config` или `.env`), и не оставляйте поля с пустыми значениями. Если Вам не нужно поле, просто удалите его.

Учтите, что чтение `.env`-файла осуществляется автоматически, если приложение запускается в docker'е
(так как в этом случае переменные окружения создаются автоматически на основе `.env`-файла).
Если Вы запускаете проект не в docker'е, Вам нужно самостоятельно позаботиться о существовании указанных в файле переменных
окружения.

## Использование API

Полная спецификация API приведена в swagger-файле, доступном по адресу http://localhost:8080/swagger/ (по 
умолчанию) после запуска проекта. Некоторые примеры запросов:

- [Создание пользователя](#users-create)
- [Создание сегмента](#segments-create)
- [Получение списка всех сегментов](#segments-getall)
- [Удаление сегмента](#segments-delete)
- [Получение списка всех пользователей](#users-getall)
- [Получение пользователя по ID с его сегментами](#users-getWithSegments)
- [Добавление пользователя в сегменты](#users-addUserToSegments)
- [Удаление пользователя из сегментов](#users-deleteUserFromSegments)
- [Создание отчёта](#users-makeReport)

### Создание пользователя<a name="users-create"></a>
`POST /api/v1/users`

Пример запроса:
```json
{
  "name": "Михаил",
  "lastname": "Иванов",
  "age": 27,
  "sex": 0
}
```

Пример ответа:
```json
{
  "id": 26
}
```

### Создание сегмента<a name="segments-create"></a>
`POST /api/v1/segments`

Пример запроса:
```json
{
  "name": "AVITO_MUSIC_SERVICE",
  "percentage": 57
}
```

Пример ответа:
```json
{
  "name": "AVITO_MUSIC_SERVICE"
}
```

Поле `percentage` запроса является необязательным и, если указано, обозначает, какой процент случайных существующих
пользователей будет автоматически добавлен в создаваемый сегмент.

### Получение списка всех сегментов<a name="segments-getAll"></a>
`GET /api/v1/segments`

Пример ответа:
```json
{
  "segments": [
    {
      "segment_id": 43,
      "name": "AVITO_MUSIC_SERVICE",
      "is_deleted": false
    }
  ]
}
```

В целях исключения потери данных, операция удаления не стирает сегменты из базы данных физически, а совершает логическое
удаление, отмечая флаг `is_deleted`. Если какой-либо запрос попытается добавить пользователю несуществующие или 
удалённые сегменты, будет создана ошибка типа `ErrSegmentNotFound`. Однако при получении списка сегментов, удалённые
сегменты беспрепятственно возвращаются в ответе.

### Удаление сегмента<a name="segments-delete"></a>
`DELETE /api/v1/segments/{name}`

Пример ответа:
```json
{
  "message": "successfully deleted segment \"AVITO_MUSIC_SERVICE\""
}
```

Для удаления сегмента используется его наименование как значение, по которому можно однозначно идентифицировать сегмент
(было решено добавить для имени сегмента ограничение уникальности).

Если попытаться удалить несуществующий сегмент, будет создана ошибка `ErrSegmentNotFound`, а если попытаться удалить
сегмент, отмеченный `is_deleted`, то будет создана ошибка `ErrSegmentDeleted`.

Если на момент удаления сегмента, в него входят какие-либо пользователи, то они автоматически выйдут из удаляемого
сегмента.

### Получение списка всех пользователей<a name="users-getall"></a>
`GET /api/v1/users`

Пример ответа:
```json
{
  "users": [
    {
      "user_id": 16,
      "name": "Михаил",
      "lastname": "Иванов",
      "sex": 0,
      "sex_text": "мужской",
      "age": 27,
      "is_deleted": false
    }
  ]
}
```

### Получение списка пользователей с их сегментами<a name="users-getAllWithSegments"></a>
`GET /api/v1/users/withSegments`

Пример ответа:
```json
{
  "users": [
    {
      "segments": [
        {
          "information_id": 179,
          "user_id": 16,
          "segment_id": 43,
          "name": "AVITO_MUSIC_SERVICE",
          "start_date": "15:27:32 01.09.2023",
          "end_date": ""
        }
      ],
      "user": {
        "user_id": 16,
        "name": "Михаил",
        "lastname": "Иванов",
        "sex": 0,
        "sex_text": "мужской",
        "age": 27,
        "is_deleted": false
      }
    }
  ]
}
```

Получение пользователей с сегментами отличается от простого получения пользователей тем, что, в первом случае, каждый
пользователь дополнительно обогащается информацией о том, в каких сегментах он состоит на момент совершения запроса к
API - эта информация перечисляется в массиве `segments`. Если для какого-то сегмента `end_date` равна пустой строке, 
это значит, что для этого пользователя не установлена дата автоматического выхода из заданного сегмента.

### Получение пользователя по ID с его сегментами<a name="users-getWithSegments"></a>
`GET /api/v1/users/{id}/withSegments`

Пример ответа:
```json
{
  "user": {
    "segments": [
      {
        "information_id": 179,
        "user_id": 16,
        "segment_id": 43,
        "name": "AVITO_MUSIC_SERVICE",
        "start_date": "15:27:32 01.09.2023",
        "end_date": ""
      }
    ],
    "user": {
      "user_id": 16,
      "name": "Михаил",
      "lastname": "Иванов",
      "sex": 0,
      "sex_text": "мужской",
      "age": 27,
      "is_deleted": false
    }
  }
}
```

Данная операция возвращает информацию только об одном пользователе, обогащая её информацией об активных сегментах
пользователя. Если пользователь не найден, будет возвращена ошибка-пояснение с кодом 404.

### Добавление пользователя в сегменты<a name="users-addUserToSegments"></a>
`POST /api/v1/users/addUserToSegments`

Пример запроса:
```json
{
  "id": 16,
  "segments": [
    {
      "end_date": "10:00:00 25.09.2023",
      "name": "AVITO_MUSIC_SERVICE"
    }
  ]
}
```

Имена сегментов, в которые необходимо добавить пользователя, перечисляются в массиве `segments`. Для каждого сегмента
опционально можно указать момент времени `end_date`, когда пользователь автоматически выйдет из сегмента. Если
не указать `end_date` для сегмента, то пользователь будет находиться в сегменте, пока его не удалить из сегмента
вручную с помощью [удаления пользователя из сегментов](#users-deleteUserFromSegments). 

Также пользователь выйдет из сегмента, если сегмент будет удалён с помощью [соответствующей команды](#segments-delete).

Пример ответа:
```json
{
  "message": "user 16 was successfully added to the segments"
}
```

Если в теле запроса будет указан несуществующий пользователь, будет создана ошибка `ErrUserNotFound`.

Если в теле запроса будут перечислены несуществующие или помеченные как удалённые сегменты, будет создана ошибка
`ErrSegmentNotFound` или `ErrSegmentDeleted` соответственно.

В списке `segments` в теле запроса не позволяется указывать несколько одинаковых сегментов (то есть в списке `segments`
не может встречаться два и более элемента с идентичными `name`). В противном случае сервер
вернёт сообщение об ошибке с кодом 400.

### Удаление пользователя из сегментов<a name="users-deleteUserFromSegments"></a>
`POST /api/v1/users/deleteUserFromSegments`

Пример запроса:
```json
{
  "id": 16,
  "segments": [
    {
      "name": "AVITO_MUSIC_SERVICE"
    }
  ]
}
```

Пример ответа:
```json
{
  "message": "user 16 was successfully removed from segments"
}
```

Логика возникновения ошибок здесь такая же, что и в [добавлении пользователя в сегменты](#users-addUserToSegments).

### Создание отчёта<a name="users-makeReport"></a>
`GET /api/v1/reports`

В зависимости от того, как Вы настроили приложение перед запуском, данный endpoint имеет два сценария ответа.

Если Вы указали в `config` или `.env` файле путь до файла, содержащего пару ключей для доступа к вашей сервисной учётной
записи в Google Cloud, то сервер попытается воспользоваться этими данными и загрузить файл с отчётом на 
гугл-диск, в ответном сообщении вернув ссылку на загруженный файл.

Пример ответа:
```json
{
  "report_date": "17:14:22 19.09.2023",
  "report": "https://drive.google.com/file/d/1kcbOzRBtpxq4n_ernm0Bn6RmkDl9BhV8/view?usp=sharing"
}
```

Если Вы не указывали конфигурацию `GOOGLE_DRIVE_JSON_FILE_PATH`, то в ответном сообщении в поле `report` будет указан
отчёт в виде строки в csv-формате.

```json
{
  "report_date": "16:56:36 19.09.2023",
  "report": "user_id,segment_name,start_date,end_date\n1,AVITO_VOICE_MESSAGES,12:35:50 01.01.2023,\n1,AVITO_MARKET,12:35:50 01.01.2023,00:00:00 01.01.2024\n1,AVITO_DELIVERY,12:35:50 01.02.2023,00:00:00 01.08.2024\n2,AVITO_VOICE_MESSAGES,12:35:46 01.03.2023,\n2,AVITO_MARKET,12:35:46 01.05.2023,00:00:00 01.01.2024\n4,AVITO_DISCOUNT_50,16:10:22 01.06.2023,\n4,AVITO_DISCOUNT_70,16:10:22 01.07.2023,\n5,AVITO_VOICE_MESSAGES,10:00:25 01.09.2023,\n6,AVITO_MUSIC_SERVICE,12:20:15 19.09.2023,10:00:00 25.09.2023\n6,AVITO_VOICE_MESSAGES,12:20:15 19.09.2023,\n"
}
```

Очередная строка отчёта содержит идентификатор пользователя, наименование сегмента, дату вхождения пользователя в этот сегмент
и дату выхода пользователя из сегмента (в случае, если она не пуста). Отчёт отсортирован по столбцу `start_date` в 
порядке возрастания.

## Решения

При разработке возникали сомнения, которые необходимо было разрешать. Эти сомнения, вместе с решениями, перечислены здесь:

1. Каким образом реализовать операцию удаления сегмента учитывая, что данные нельзя терять?
> Сперва стоит коротко описать схему БД, которая содержит всего 3 таблицы:
> - users
>
> Таблица содержит столбцы, характеризующие пользователя (имя, возраст, ...) и первичный ключ user_id.
> 
> - segments
>
> Таблица содержит три столбца - segment_id, name и is_deleted. Я решил, что наименование каждого сегмента должно быть
> уникальным, поэтому столбец name имеет ограничение UNIQUE.
> 
> - users_segments
> 
> Ассоциативная таблица, характеризующая связь пользователей с сегментами. Содержит столбцы id (первичный ключ), user_id,
> segment_id, start_date (дата вхождения пользователя user_id в сегмент segment_id), end_date (дата выхода пользователя
> из сегмента, допускает NULL).
>
> Возвращаясь к вопросу о способе удаления сегментов, было принято решение не удалять сегменты физически (стирая их 
> из таблицы), так как при таком подходе, в дальнейшем, будет невозможно узнать, в каком сегменте состоял пользователь 
> на тот или иной момент времени. Если удалять сегменты из таблицы `segments` физически, то 
> в таблице `users_segments` останется запись о том, что пользователь `user_id` входил в сегмент `segment_id` на момент
> времени `start_date`-`end_date`, но с этой записью нельзя будет сопоставить никакой сегмент из `segments` (так как сегмент
> был удалён), и мы не сможем узнать наименование этого сегмента.
> 
> Таким образом, сегмент не удаляется из таблицы `segments`, а лишь помечается в ней столбцом `is_deleted`. Если 
> осуществляется операция создания сегмента с именем, которым помечен удалённый сегмент, то удалённый сегмент 
> восстанавливается (`is_deleted` принимает значение `false`).
> 
> В свою очередь, TTL сегмента реализован простым добавлением столбца `end_date` в таблицу `users_segments`. Этот
> столбец характеризует дату "разрыва отношений" между указанным пользователем и указанным сегментом. Если для сегмента
> не задан TTL, значит для соответствующей записи в таблице `users_segments` столбец `end_date`
> будет содержать `NULL` - это индикатор того, что у текущих отношений пользователя с сегментом не предусмотрен конец, и что
> разорвать их можно только вручную - удалив пользователя из сегмента, или удалив сегмент.


2. Отступление от тех. задания.
> В техническом задании имеет место формулировка: "Метод добавления пользователя в сегмент. Принимает список slug 
> (названий) сегментов которые, нужно добавить пользователю, список slug (названий) сегментов, которые нужно удалить у 
> пользователя, id пользователя."
> 
> Было решено отступить от такой формулировки и разделить единый метод на два отдельных - для 
> удобства. Так появились два метода: метод, добавляющий пользователя в сегменты, и метод, удаляющий пользователя из 
> сегментов.

3. Как поступать при удалении сегмента, TTL которого ещё не истёк?
> Если осуществляется операция удаления сегмента, для которого TTL ещё не истёк, можно поступить двумя способами:
> удалить всех пользователей из этого сегмента сейчас, или не удалять до тех пор, пока не истечёт TTL сегмента.
> 
> Было решено убирать пользователей из удаляемого сегмента сразу в момент удаления сегмента, невзирая на возможный TTL, так как будет
> весьма странно, если применить операцию удаления сегмента, а затем запросить информацию о пользователе и увидеть в 
> списке его сегментов только что удалённый сегмент.
> 
> Такой подход избавляет нас и от коллизии между сегментами, которая может быть вызвана тем, что наши сегменты удаляются
> не физически, а логически. Если бы мы удалили сегмент, оставив пользователей в нём до истечения его TTL, то,
> создав новый сегмент с таким же именем (а фактически просто восстановив старый, с прежним `segment_id`), мы удивимся, когда не
> сможем добавить пользователя в "новый" сегмент, так как `segment_id` "нового" сегмента совпадает с `segment_id` только что удалённого сегмента,
> в котором всё ещё находится пользователь, ибо у удалённого сегмента не истёк TTL. Другими словами, будет считаться, что мы пытаемся добавить
> пользователя в сегмент, которому он уже принадлежит.
> 
> Если же убирать пользователя из сегмента в момент удаления сегмента, такой проблемы не возникнет, так
> как новый сегмент с прежним именем уже будет действовать в других временных рамках, которые не пересекаются с временными
> рамками существования удалённого сегмента.
 
## TODO
1. Unit-тесты для слоя controller; (✔)
2. Реализовать загрузку отчёта на внешний файлообменник с возвратом ссылки на загруженный csv-файл; (✔)
3. Добавить для запроса на создание отчёта параметры, позволяющие ограничивать столбцы `start_date` и `end_date` отчёта;
