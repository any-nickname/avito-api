![gopher image](https://raw.githubusercontent.com/tottie000/GopherIllustrations/main/Gopher_Illustrations/channel.png)

_<font size="2">The Go gopher was designed by Renée French. Illustrations by tottie.</font>_

# Сервис по работе с сегментами

Проект представляет собой микросервис, предоставляющий функционал по работе с сегментами пользователей.
Проект предназначен для решения задач аналитики.

Технологии:
- PostgreSQL (хранилище данных)
- Docker (для развёртывания dev-среды)
- Swagger (документация API)
- Echo (веб-фреймворк)
- pgx (драйвер для работы с PostgreSQL)

Проект построен согласно идеям чистой архитектуры, что позволяет, при необходимости, комфортно и быстро расширять его в
будущем.
Для плавного выключения сервиса реализован Graceful Shutdown.

## Запуск проекта

Для запуска проекта используйте команду `make up` (перед использованием команды `make` на компьютере должна быть
установлена GNU Make).

После запуска, для того, чтобы проверить работу бекэнда, Вы можете отправить GET-запрос по адресу
http://localhost:8080/health

Для доступа к swagger-файлу перейдите по адресу http://localhost:8080/swagger/

Для повторной сборки проекта с нуля (что может быть полезно в случае внесения изменений в проект), используйте команду `make rm` для удаления директорий и файлов, создаваемых в
процессе сборки контейнера, а затем снова используйте команду `make up`.

Для изменения настроек запуска проекта используйте `.env`-файл или `config.yaml` (они допускают одинаковый набор 
значений). Обратите внимание, что значения, указанные в `.env`-файле, имеют приоритет над значениями из `config.yaml`.

Для запуска unit-тестов используйте команду `make test`.

Для автоматической генерации swagger-файла используйте команду `make swag`.

## Использование API

Полная спецификация API приведена в swagger-файле, доступном по адресу http://localhost:8080/swagger/ (по 
умолчанию) после запуска проекта. Некоторые примеры запросов:

- [Создание пользователя](#users-create)
- [Создание сегмента](#segments-create)
- [Получение списка всех сегментов](#segments-getall)
- [Удаление сегмента](#segments-delete)
- [Получение списка всех пользователей](#users-getall)
- [Получение пользователя по ID с его сегментами](#users-getWithSegments)
- [Добавление пользователя в сегменты](#users-addUserToSegments)
- [Удаление пользователя из сегментов](#users-deleteUserFromSegments)
- [Создание отчёта](#users-makeReport)

### Создание пользователя<a name="users-create"></a>
`POST /api/v1/users`

Пример запроса:
```json
{
  "name": "Михаил",
  "lastname": "Иванов",
  "age": 27,
  "sex": 0
}
```

Пример ответа:
```json
{
  "id": 26
}
```

### Создание сегмента<a name="segments-create"></a>
`POST /api/v1/segments`

Пример запроса:
```json
{
  "name": "AVITO_MUSIC_SERVICE",
  "percentage": 57
}
```

Пример ответа:
```json
{
  "name": "AVITO_MUSIC_SERVICE"
}
```

Поле `percentage` запроса является необязательным и, если указано, обозначает, какой процент случайных существующих
пользователей будет автоматически добавлен в создаваемый сегмент.

### Получение списка всех сегментов<a name="segments-getAll"></a>
`GET /api/v1/segments`

Пример ответа:
```json
{
  "segments": [
    {
      "segment_id": 43,
      "name": "AVITO_MUSIC_SERVICE",
      "is_deleted": false
    }
  ]
}
```

В целях исключения потери данных, операция удаления не стирает сегменты из базы данных физически, а совершает логическое
удаление, отмечая флаг `is_deleted`. Если какой-либо запрос попытается добавить пользователю несуществующие или 
удалённые сегменты, будет создана ошибка типа `ErrSegmentNotFound`. Однако при получении списка сегментов, удалённые
сегменты беспрепятственно возвращаются в ответе.

### Удаление сегмента<a name="segments-delete"></a>
`DELETE /api/v1/segments/{name}`

Пример ответа:
```json
{
  "message": "successfully deleted segment \"AVITO_MUSIC_SERVICE\""
}
```

Для удаления сегмента используется его наименование как значение, по которому можно однозначно идентифицировать сегмент
(было решено добавить для имени сегмента ограничение уникальности).

Если попытаться удалить несуществующий сегмент, будет создана ошибка `ErrSegmentNotFound`, а если попытаться удалить
сегмент, отмеченный `is_deleted`, то будет создана ошибка `ErrSegmentDeleted`.

Если на момент удаления сегмента, в него входят какие-либо пользователи, то они автоматически выйдут из удаляемого
сегмента.

### Получение списка всех пользователей<a name="users-getall"></a>
`GET /api/v1/users`

Пример ответа:
```json
{
  "users": [
    {
      "user_id": 16,
      "name": "Михаил",
      "lastname": "Иванов",
      "sex": 0,
      "sex_text": "мужской",
      "age": 27,
      "is_deleted": false
    }
  ]
}
```

### Получение списка пользователей с их сегментами<a name="users-getAllWithSegments"></a>
`GET /api/v1/users/withSegments`

Пример ответа:
```json
{
  "users": [
    {
      "segments": [
        {
          "information_id": 179,
          "user_id": 16,
          "segment_id": 43,
          "name": "AVITO_MUSIC_SERVICE",
          "start_date": "15:27:32 01.09.2023",
          "end_date": ""
        }
      ],
      "user": {
        "user_id": 16,
        "name": "Михаил",
        "lastname": "Иванов",
        "sex": 0,
        "sex_text": "мужской",
        "age": 27,
        "is_deleted": false
      }
    }
  ]
}
```

Получение пользователей с сегментами отличается от простого получения пользователей тем, что, в первом случае, каждый
пользователь дополнительно обогащается информацией о том, в каких сегментах он состоит на момент совершения запроса к
API - эта информация перечисляется в массиве `segments`. Если для какого-то сегмента `end_date` равна пустой строке, 
это значит, что для этого пользователя не установлена дата автоматического выхода из заданного сегмента.

### Получение пользователя по ID с его сегментами<a name="users-getWithSegments"></a>
`GET /api/v1/users/{id}/withSegments`

Пример ответа:
```json
{
  "user": {
    "segments": [
      {
        "information_id": 179,
        "user_id": 16,
        "segment_id": 43,
        "name": "AVITO_MUSIC_SERVICE",
        "start_date": "15:27:32 01.09.2023",
        "end_date": ""
      }
    ],
    "user": {
      "user_id": 16,
      "name": "Михаил",
      "lastname": "Иванов",
      "sex": 0,
      "sex_text": "мужской",
      "age": 27,
      "is_deleted": false
    }
  }
}
```

Данная операция возвращает информацию только об одном пользователе, обогащая её информацией об активных сегментах
пользователя. Если пользователь не найден, будет возвращена ошибка-пояснение с кодом 404.

### Добавление пользователя в сегменты<a name="users-addUserToSegments"></a>
`POST /api/v1/users/addUserToSegments`

Пример запроса:
```json
{
  "id": 16,
  "segments": [
    {
      "end_date": "10:00:00 25.09.2023",
      "name": "AVITO_MUSIC_SERVICE"
    }
  ]
}
```

Имена сегментов, в которые необходимо добавить пользователя, перечисляются в массиве `segments`. Для каждого сегмента
опционально можно указать момент времени `end_date`, когда пользователь автоматически выйдет из сегмента. Если
не указать `end_date` для сегмента, то пользователь будет находиться в сегменте, пока его не удалить из сегмента
вручную с помощью [удаления пользователя из сегментов](#users-deleteUserFromSegments). 

Также пользователь выйдет из сегмента, если сегмент будет удалён с помощью [соответствующей команды](#segments-delete).

Пример ответа:
```json
{
  "message": "user 16 was successfully added to the segments"
}
```

Если в теле запроса будет указан несуществующий пользователь, будет создана ошибка `ErrUserNotFound`.

Если в теле запроса будут перечислены несуществующие или помеченные как удалённые сегменты, будет создана ошибка
`ErrSegmentNotFound` или `ErrSegmentDeleted` соответственно.

### Удаление пользователя из сегментов<a name="users-deleteUserFromSegments"></a>
`POST /api/v1/users/deleteUserFromSegments`

Пример запроса:
```json
{
  "id": 16,
  "segments": [
    {
      "name": "AVITO_MUSIC_SERVICE"
    }
  ]
}
```

Пример ответа:
```json
{
  "message": "user 16 was successfully removed from segments"
}
```

Логика возникновения ошибок здесь такая же, что и в [добавлении пользователя в сегменты](#users-addUserToSegments)

### Создание отчёта<a name="users-makeReport"></a>
`GET /api/v1/reports`

Пример ответа:
```json
{
  "report_date": "19:52:04 02.09.2023",
  "report": "user_id,segment_name,start_date,end_date\n1,AVITO_VOICE_MESSAGES,12:35:50 01.01.2023,\n"
}
```

В связи с нехваткой времени было принято решение формировать и возвращать отчёт прямо в теле ответа.

Строка отчёта содержит идентификатор пользователя, наименование сегмента, дату вхождения пользователя в этот сегмент
и дату выхода пользователя из сегмента (в случае, если она не пуста). Отчёт отсортирован по столбцу `start_date` в 
порядке возрастания.

## Решения

При разработке возникали сомнения, которые необходимо было разрешать. Эти сомнения, вместе с решениями, перечислены здесь:

1. Каким образом реализовать операцию удаления сегмента учитывая, что данные нельзя терять?
> Сперва стоит коротко описать схему БД, которая содержит всего 3 таблицы:
> - users
>
> Таблица содержит столбцы, характеризующие пользователя (имя, возраст, ...) и первичный ключ user_id.
> 
> - segments
>
> Таблица содержит три столбца - segment_id, name и is_deleted. Я решил, что наименование каждого сегмента должно быть
> уникальным, поэтому столбец name имеет ограничение UNIQUE.
> 
> - users_segments
> 
> Ассоциативная таблица, характеризующая связь пользователей с сегментами. Содержит столбцы id (первичный ключ), user_id,
> segment_id, start_date (дата вхождения пользователя user_id в сегмент segment_id), end_date (дата выхода пользователя
> из сегмента, допускает NULL).
>
>  Возвращаясь к вопросу о способе удаления сегментов, было принято решение не удалять сегменты физически (стирая их 
> из таблицы), так как при таком подходе, в дальнейшем, будет невозможно узнать, в каком сегменте состоял пользователь 
> на тот или иной момент времени, так как останется лишь идентификатор сегмента, но не его наименование, так как для 
> связи пользователей и сегментов используется ассоциативная таблица `users_segments`.
> 
> Таким образом, сегмент не удаляется из таблицы `segments`, а лишь помечается в ней столбцом `is_deleted`. Если 
> осуществляется операция создания сегмента с именем, которым помечен удалённый сегмент, то удалённый сегмент 
> восстанавливается (`is_deleted` принимает значение `false`).
> 
> В свою очередь, TTL сегмента реализован простым добавлением столбца `end_date` в таблицу `users_segments`. Этот
> столбец характеризует дату "разрыва отношений" между указанным пользователем и указанным сегментом. Если для сегмента
> не задан TTL, значит для соответствующей записи в таблице `users_segments` столбец `end_date`
> будет содержать `NULL` - это индикатор того, что у текущих отношений пользователя с сегментом не предусмотрен конец, и что
> разорвать их можно только вручную - удалив пользователя из сегмента, или удалив сегмент.


2. Отступление от тех. задания.
> В техническом задании имеет место формулировка: "Метод добавления пользователя в сегмент. Принимает список slug 
> (названий) сегментов которые, нужно добавить пользователю, список slug (названий) сегментов, которые нужно удалить у 
> пользователя, id пользователя."
> 
> Было решено отступить от такой формулировки и разделить единый метод на два отдельных - для 
> удобства. Так появились два метода: метод, добавляющий пользователя в сегменты, и метод, удаляющий пользователя из 
> сегментов.

3. Как поступать при удалении сегмента, TTL которого ещё не истёк?
> Если осуществляется операция удаления сегмента, для которого TTL ещё не истёк, можно поступить двумя способами:
> удалить всех пользователей из этого сегмента сейчас, или не удалять до тех пор, пока не истечёт TTL сегмента.
> 
> Было решено убирать пользователей из удаляемого сегмента сразу в момент удаления сегмента, невзирая на возможный TTL, так как будет
> весьма странно, если применить операцию удаления сегмента, а затем запросить информацию о пользователе и увидеть в 
> списке его сегментов только что удалённый сегмент.
> 
> Такой подход избавляет нас и от коллизии между сегментами, которая может быть вызвана тем, что наши сегменты удаляются
> не физически, а логически. Если бы мы удалили сегмент, оставив пользователей в нём до истечения его TTL, то,
> создав новый сегмент с таким же именем (а фактически просто восстановив старый, с прежним `segment_id`), мы удивимся, когда не
> сможем добавить пользователя в "новый" сегмент, так как `segment_id` "нового" сегмента совпадает с `segment_id` только что удалённого сегмента,
> в котором всё ещё находится пользователь, ибо у удалённого сегмента не истёк TTL. Другими словами, будет считаться, что мы пытаемся добавить
> пользователя в сегмент, которому он уже принадлежит.
> 
> Если же убирать пользователя из сегмента в момент удаления сегмента, такой проблемы не возникнет, так
> как новый сегмент с прежним именем уже будет действовать в других временных рамках, которые не пересекаются с временными
> рамками существования удалённого сегмента.
 
## TODO
1. Unit-тесты для слоя controller; (✔)
2. Реализовать загрузку отчёта на внешний файлообменник с возвратом ссылки на загруженный csv-файл;
3. Добавить для запроса на создание отчёта параметры, позволяющие ограничивать столбцы `start_date` и `end_date` отчёта;
